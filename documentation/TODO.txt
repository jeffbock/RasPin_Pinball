This file tracks the various items to do in the pinball project in rough priority

** Raspberry Pi Specific Work
Enable and debug Neopixel code on a real Raspberry Pi (currently untested)

** Generic arch improvements
* Continue to improve managing pinball states, modes, and lighting.. still pretty basic in current implementation

** Gameplay tasks - will evolve as HW becomes more capable
Implement first flipping / scoring capability on main screen
Define modes and rules for each
Add dungeon exploring and combat screens 

** Hardware enabling
Design prototype HW, use test mode to enable
    * Flippers, Sligshots, Pop Bumpers, Lane / Ball Detectors, Multiball lock gate
    * Build proto cabinet w/ foam board
Build relay output boards that connect to output IO chips.  Likely FET controlled, opto-isolated and support multiple voltage output ranges
    * Put the scematics for all boards into DigiKey for documenting.  See how much cost to build for real?
Add fuses to protect HW / boards
Add capapacitors to I/O boards for noise reduction, solenoid surge protection

** Lower Priority
Refactor redudant input messages (output messages now not type (eg: flipper) specific) - do same for inputs?
Bug: Debug why u1 and u2 and x1 and x2 seem to be swapped when going from screen to 3D space.  Maybe rendering backface polys
Align sounds to less popping - align sample modes, use WAV?
Protect input / output queues with mutex and make them multi-thread?  Doesn't seem to be needed with current design
Expand sprites to have animated sprites - eg: UV maps within a sprite with different images - base is there but need example to integrate.
    -  Is there some standard sprite format / program that can be used?
    -  Or add basic capability to animate more automatically between different sprites / loop / etc..
Actually checkout the CMAKE flow - I don't use it a lot right now

** Maybe future stuff
Add a 3D model sprite - allow for 3D objects on the screens, basic animations, etc.. Tons of work here depending on how complicated