// New PBProcessOutput flow - replace PBProcessOutput() for Rasberry Pi versions of the function

// First, modify SendOutputMsg to match the new structure for stOutputMessage (along with it's options structure)

// Then Use the old version of PBProcessOutput as a base reference, but modify the flow as follows.  Indentation is for clarity of the flow/brackets, but should be adjusted as needed for readability and efficiency 

// Pop an output message from the output queue (m_outputQueue) until empty
// If the message is for an IO chip or RASPI output
//   Check to see if it's currently in the pulse output map (m_outputPulseMap) - if so, ignore drop the message go to next message
//   Check to see if it's a pulse output, if so, put it in the pulse output map (index of OutputID), along with on / off times and start time
//   If not a pulse output, stage it to the appropriate IODriver chip or if RASPI output, send it immediately to the GPIO pin
// If the message is for an LED chip
//   Check to see if a LED display sequence (m_LEDSequenceInfo) is active for that chip based on the sequence enabled boolean and the sequence chip mask (sequenceMask) which specifies which chips are in the sequence, if so, push the message to the deferred LED queue (m_deferredQueue) and go to next message.  
//      Ensure the deferred queue has a max size (MAX_DEFERRED_LED_QUEUE) and drop messages if it exceeds that size. 
//   Otherwise, If the LED message is for a state control (PB_OMSG_LEDCFG*), send it to the LED chip immediately
//   Otherwise, If the LED message is for a pin control (PB_OMSG_LED or PB_OMSG_LEDSET_BRIGHTNESS), stage it to the correct LED chip
// If the message is to start an LED sequence (PB_OMSG_LED_SEQUENCE), start the LED sequence mode
//  If a LED sequence is already active, the new sequence will replace the old one
//  Set a boolean to reflect start of the mode, and update the sequence chip mask to reflect affected chips.  Record the start time, save the LEDDriver outputs (16 bits each chip) (savedLEDValues) values of the chips defined in the mask and reset the sequence index to 0
// If the message is to stop an LED sequence, end the LED sequence mode, stage the saved values to the LEDDriver chips based on the sequence chip mask
// When all messages have been processed
//  For each entry in the pulse map (m_outputPulseMap), check require on time and required off time, and stage the correct value to the IO chip or send value directly to RaspPI GPIO. Remove from the map when done
// Send all staged outputs to the IODriver chips
// If in LED sequence mode
//  Check to see if the sequence time has completed, if so, end the mode and stage LEDDriver outputs to the formerly saved values based on the sequence chip mask
//  If sequence index is zero (currentSeqIndex) and this is the first time through, stage the LEDDriver outputs chips specified by the sequence chip mask to the first entry in the sequence
//  else check if the time for the current sequence index has expired (calculate appripropriately if sequence is going up or down and the loop mode)
//    Add the IndexStep (indexStep) value to the Index (this could be +1 or -1 depending on direction)
//    If index is >= sequence length check the loop mode variable of the sequence (loopMode)
//      If loop mode is NOLOOP, end the sequence mode and stage LEDDriver outputs to the intial saved values based on the sequence chip mask
//      If loop mode is LOOP, set index to zero and stage LEDDriver outputs to the first entry in the sequence, reset the start time, based on the sequence chip mask
//      If loop mode is PINGPONG or PINGPONGLOOP, reverse the IndexStep direction, adjust the index, and stage LEDDriver outputs to the new index in the sequence based on the sequence chip mask.  Use the current time to record the end time of the forward pass of the sequence
//    If index is < 0 sequence length check the loop mode variable of the sequence
//      If loop mode is NOLOOP, end the sequence mode and stage LEDDriver outputs to the intial saved values based on the sequence chip mask
//      If loop mode is LOOP, set index to zero, change IndexStep value to +1, reset the start time
//      If loop mode is PINGPONG or PINGPONGLOOP, reverse the IndexStep direction, adjust the index, and stage LEDDriver outputs to the new index in the sequence based on the sequence chip mask.  Use the current time to record the end time of the forward pass of the sequence
//    If index is between 0 and sequence length, stage LEDDriver outputs to the current index in the sequence based on the sequence chip mask
// else if not in LED sequence mode and there are messages in the deferred LED queue
//    Pop each message from the deferred LED queue and process it as above for LED messages (since this is the same as above, a function should be created to handle this)
// Send all staged outputs to all LED chips
// Return true if everything processed ok
// Can break this flow into multiple functions if to large and improve readability, particularly calcuating current indexes for sequences and values for outputs for sequences and pulses.  But it needs to be efficient as this is called frequently.
